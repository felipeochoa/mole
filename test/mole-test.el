;;; mole-tests --- Tests for mole.js  -*- lexical-binding: t -*-
;; Package-Requires: ((emacs "24.4"))

;;; Commentary:

;;; Code:

(require 'ert)
(require 'ert-x)
(require 'f)

(load (f-expand "mole" (f-parent (f-dirname (f-this-file)))))

(ert-deftest mole-builders-terminal ()
  (ert-with-test-buffer (:name 'mole-builders-terminal)
    (insert "teeeest")
    (goto-char (point-min))
    (let ((res (mole-build-terminal '(test "te+st"))))
      (should (eq (car res) 'test))
      (should (funcall `(lambda ,@(cdr res))))
      (should (eq (point) (point-max)))
      (save-excursion (insert "!teeeest"))
      (should (null (funcall `(lambda ,@(cdr res))))))))

(ert-deftest mole-builders-sequence ()
  (ert-with-test-buffer (:name 'mole-builders-sequence)
    (insert "teeeest")
    (goto-char (point-min))
    (let ((res (mole-build-nonterminal '(nonterminal "t" "e+" "st"))))
      (should (eq (car res) 'nonterminal))
      (should (funcall `(lambda ,@(cdr res))))
      (should (eq (point) (point-max)))
      (save-excursion (insert "teeees"))
      (should (null (funcall `(lambda ,@(cdr res))))))))

(ert-deftest mole-builders-zero-or-more ()
  (ert-with-test-buffer (:name 'mole-builders-sequence)
    (goto-char (point-min))
    (let ((res (mole-build-nonterminal '(nonterminal (* "t" "a")))))
      (should (eq (car res) 'nonterminal))
      (should (funcall `(lambda ,@(cdr res))))
      (save-excursion (insert "tatatata"))
      (should (funcall `(lambda ,@(cdr res))))
      (should (eq (point) (point-max)))
      (save-excursion (insert "n"))
      (should (funcall `(lambda ,@(cdr res))))
      (should (eq (point) (1- (point-max)))))))

(ert-deftest mole-builders-one-or-more ()
  (ert-with-test-buffer (:name 'mole-builders-sequence)
    (goto-char (point-min))
    (let ((res (mole-build-nonterminal '(nonterminal (+ "t" "a")))))
      (should (eq (car res) 'nonterminal))
      (should (null (funcall `(lambda ,@(cdr res)))))
      (save-excursion (insert "tatatata"))
      (should (funcall `(lambda ,@(cdr res))))
      (should (eq (point) (point-max)))
      (save-excursion (insert "n"))
      (should (null (funcall `(lambda ,@(cdr res)))))
      (should (eq (point) (1- (point-max)))))))

(ert-deftest mole-builders-zero-or-one ()
  (ert-with-test-buffer (:name 'mole-builders-sequence)
    (goto-char (point-min))
    (let* ((res (mole-build-nonterminal '(nonterminal (? "t" "a"))))
           (name (car res))
           (func `(lambda ,@(cdr res))))
      (should (eq (car res) 'nonterminal))
      (should (funcall func))
      (save-excursion (insert "tatatata"))
      (should (funcall func))
      (should (eq (point) (+ 2 (point-min))))
      (let ((curr (point)))
        (save-excursion (insert "n"))
        (should (funcall func))
        (should (eq (point) curr))))))

(ert-deftest mole-builders-or ()
  (ert-with-test-buffer (:name 'mole-builders-sequence)
    (goto-char (point-min))
    (let* ((res (mole-build-nonterminal '(nonterminal (or "t" "e"))))
           (name (car res))
           (func `(lambda ,@(cdr res))))
      (should (eq (car res) 'nonterminal))
      (should (null (funcall func)))
      (save-excursion (insert "test"))
      (should (funcall func))
      (should (eq (point) (1+ (point-min))))
      (should (funcall func))
      (should (eq (point) (+ 2 (point-min))))
      (should (null (funcall func)))
      (should (eq (point) (+ 2 (point-min)))))))

(ert-deftest mole-builders-lookahead ()
  (ert-with-test-buffer (:name 'mole-builders-sequence)
    (goto-char (point-min))
    (let* ((res (mole-build-nonterminal '(nonterminal (?= "te" "st"))))
           (name (car res))
           (func `(lambda ,@(cdr res))))
      (should (eq (car res) 'nonterminal))
      (should (null (funcall func)))
      (should (eq (point) (point-min)))
      (save-excursion (insert "test"))
      (should (funcall func))
      (should (eq (point) (point-min)))
      (forward-char 1)
      (should (null (funcall func)))
      (should (eq (point) (1+ (point-min)))))))

(ert-deftest mole-builders-negative-lookahead ()
  (ert-with-test-buffer (:name 'mole-builders-sequence)
    (goto-char (point-min))
    (let* ((res (mole-build-nonterminal '(nonterminal (?! "te" "st"))))
           (name (car res))
           (func `(lambda ,@(cdr res))))
      (should (eq (car res) 'nonterminal))
      (should (funcall func))
      (should (eq (point) (point-min)))
      (save-excursion (insert "test"))
      (should (null (funcall func)))
      (should (eq (point) (point-min)))
      (forward-char 1)
      (should (funcall func))
      (should (eq (point) (1+ (point-min)))))))

(ert-deftest mole-basic-grammar-test ()
  "Test a very simple expression grammar."
  (let ((g (mole-create-grammar
            ((whitespace "[ \t\n\f]*")
             (number "[0-9]+"))
            ((expression product (* (or "\\+" "-") product))
             (product number (* (or "\\*" "/") number))))))
    (should (equal (mole-node-to-sexp (mole-parse-string g 'expression "3 + 2 * 6"))
                   '(expression
                     (product (number "3"))
                     "+"
                     (product (number "2") "*" (number "6")))))))

(provide 'mole-tests)
;;; mole-test.el ends here
